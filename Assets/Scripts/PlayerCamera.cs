using UnityEngine;
using System.Collections;
using UnityEngine.Networking;

public class PlayerCamera : NetworkBehaviour
{
    /// <summary>
    /// The sensitivity when pressing A-D and left-right on the keyboard.
    /// </summary>
    [SerializeField]
    private float keyboardXSensitivity = 0.25f;

    /// <summary>
    /// The sensitivity when pressing S-W and down-up on the keyboard.
    /// </summary>
    [SerializeField]
    private float keyboardYSensitivity = 0.25f;

    /// <summary>
    /// The sensitivity when moving the mouse left-right.
    /// </summary>
    [SerializeField]
    private float mouseXSensitivity = 0.25f;

    /// <summary>
    /// The sensitivity when moving the mouse down-up.
    /// </summary>
    [SerializeField]
    private float mouseYSensitivity = 0.25f;

    /// <summary>
    /// The sensitivity when using the mouse scrollwheel.
    /// </summary>
    [SerializeField]
    private float mouseScrollSensitivity = 5.0f;

    /// <summary>
    /// The distance to snap to when selecting an object.
    /// </summary>
    [SerializeField]
    private float objectSelectSnapDistance = 5.0f;

    /// <summary>
    /// The player camera object.
    /// </summary>
    public Camera playerCamera;

    // Various private input state variables
    Vector3 keyboardMovement, mouseMovement;
    private bool mouseLeftPress, mouseMiddlePress, mouseRightPress;
    private bool mouseLeftHold, mouseMiddleHold, mouseRightHold;
    private bool mouseLeftRelease, mouseMiddleRelease, mouseRightRelease;

    /// <summary>
    /// The transform tag that is checked to determine whether or not an object is selectable.
    /// </summary>
    const string selectableTag = "Selectable";


    /// <summary>
    /// Perform initialization on the camera object.
    /// </summary>
    [ClientCallback]
    private void Start()
    {
        playerCamera.enabled = isLocalPlayer;
        return;
	}

	
	/// <summary>
    /// Run an update once per game frame.
    /// </summary>
    [ClientCallback]
	private void Update()
    {
        if (!isLocalPlayer) // If we're not updating a local player, return
        {
            return;
        }

        Vector3 movement;
        GetInput(out movement);
        CheckForObjectSelect();
        ApplyMovement(movement);

        return;
	}


    /// <summary>
    /// Get input from various sources.
    /// </summary>
    /// <param name="movement">The movement vector generated by the input.</param>
    private void GetInput(out Vector3 movement)
    {
        // Mouse button press statuses
        mouseLeftPress = Input.GetMouseButtonDown(0);
        mouseMiddlePress = Input.GetMouseButtonDown(2);
        mouseRightPress = Input.GetMouseButtonDown(1);

        // Mouse button hold statuses
        mouseLeftHold = Input.GetMouseButton(0);
        mouseMiddleHold = Input.GetMouseButton(2);
        mouseRightHold = Input.GetMouseButton(1);

        // Mouse button release statuses
        mouseLeftRelease = Input.GetMouseButtonUp(0);
        mouseMiddleRelease = Input.GetMouseButtonUp(2);
        mouseRightRelease = Input.GetMouseButtonUp(1);

        // Movement statuses
        keyboardMovement = new Vector3(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));
        mouseMovement = new Vector3(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y"),
            Input.GetAxis("Mouse ScrollWheel"));
        
        AssignMovement(out movement); // Get the movement values resulting from the input state

        return;
    }


    /// <summary>
    /// Determine movement values based on input states.
    /// </summary>
    /// <param name="movement">The movement vector generated by the input.</param>
    private void AssignMovement(out Vector3 movement)
    {
        movement = new Vector3();

        if (mouseMiddleHold || mouseRightHold) // Allow mouse movement to override keyboard movement
        {
            movement.x = mouseMovement.x * mouseXSensitivity;
            movement.y = mouseMovement.y * mouseYSensitivity;
        }
        else
        {
            movement.x = keyboardMovement.x * keyboardXSensitivity;
            movement.y = keyboardMovement.y * keyboardYSensitivity;
        }
        movement.z = mouseMovement.z * mouseScrollSensitivity;

        return;
    }


    /// <summary>
    /// Check if the user has selected a selectable item and snap the camera to it.
    /// </summary>
    private void CheckForObjectSelect()
    {
        Ray ray = playerCamera.ScreenPointToRay(Input.mousePosition);
        RaycastHit hitInfo;

        if (SelectObject() && Physics.Raycast(ray, out hitInfo, playerCamera.farClipPlane))
        {
            Transform selectable = hitInfo.transform.FindChild(selectableTag);
            if (selectable != null)
            {
                transform.position = selectable.position - new Vector3(-objectSelectSnapDistance, 0.0f, 0.0f);
            }
        }

        return;
    }


    /// <summary>
    /// Apply the movement determined from user input to the camera.
    /// </summary>
    /// <param name="movement">The movement vector to apply.</param>
    private void ApplyMovement(Vector3 movement)
    {
        if (RotateCamera())
        {
            // TODO: Add rotation logic here
        }
        else
        {
            transform.Translate(movement);
        }
        return;
    }


    /// <summary>
    /// Check if the user's input denotes a desire to select a game object.
    /// </summary>
    /// <returns>A boolean representing whether or not the user used the game object selection input.</returns>
    private bool SelectObject()
    {
        return mouseLeftPress;
    }


    /// <summary>
    /// Check if the user's input denotes a desire to rotate the camera.
    /// </summary>
    /// <returns>A boolean representing whether or not the user used the camera rotation input.</returns>
    private bool RotateCamera()
    {
        return mouseMiddleHold;
    }

}
